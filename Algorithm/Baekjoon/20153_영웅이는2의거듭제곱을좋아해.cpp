/*
20153 영웅이는 2의 거듭 제곱을 좋아해!

비트마스킹 문제 
 
[22] 배열로 만들려다가, 완전 탐색 중에 빼고 더하려면 불필요하게 2번 돌길래 고민하다가 
22개 밖에 없으니 비트 연산이 가능하다는 것을 깨달음
 
그러면 홀수도 반드시 홀수개를 셀 필요 없이 짝수가 되면 0 으로 바꾸면 됨 

짝-짝 = 짝
짝-홀 = 홀
홀-짝 = 홀
홀-홀 = 짝

현재 수 (count) 가 홀수일 때 홀수를 빼면 짝수가 되므로 - 해줘야함
현재 수가 홀수일 때, 짝수를 빼면 여전히 홀수이므로 변화 없음
현재 수가 짝수일 때, 짝수를 빼면 변화 없음
현재 수가 짝수일 때, 홀수를 빼면 홀수로 바뀌므로 + 해줘야함
=> 따라서 2가지 경우만 고려하면 되고,
0과 1로만 표시되었기 때문에 전체 개수를 다 셌을 때 0 개인 경우와 짝수를 어떻게 고려하느냐 할 수 있는데
check 값이 있다는 건 이미 그 값이 더해졌다는 뜻이다. 따라서 0개일 수가 없음 

문제의 두번째 예제 덕분에 지문의 의미를 깨달음
"최대 한 개의 자연수를 제거" -> 제거하지 않을 수도 있음 
*/

#include <stdio.h>
int check[2222222];
int count;
long long cur;
long long m;

int main(void) {
	int N,A;
	scanf("%d", &N);
	for (int i = 0; i < N; ++i) {
		scanf("%d", &A);
		for (int j = 0; j < 22; ++j) {
			if (A <= 0) break;
			if (A & 1) {
				check[i] |= (1 << j);
				if ((count >> j) & 1) { // 홀수 -> 짝수가 될 예정 
					cur -= (1LL << j);
					count &= ~(1 << j);
				}
				else {
					cur += (1LL << j);	
					count |= (1 << j);
				}
			}
			A >>= 1;
		}
	}
	m = cur; // 최대 한 개의 자연수 제거 
	for (int i = 0; i < N; ++i) {
		long long temp = cur;
		for (int j = 0; j < 22; ++j) {
			if ((check[i] >> j) & 1) { // 홀수 개 
				if ((count >> j) & 1) { // 홀수 개 
					temp -= (1LL << j); // 홀 - 홀  = 짝 
				} else { // 짝수 개 
					temp += (1LL << j); // 짝 - 홀 = 홀 
				}
			}
		}
		if (temp > m) m = temp;
	}
	printf("%lld%lld\n", m, m);
	return 0;
}
