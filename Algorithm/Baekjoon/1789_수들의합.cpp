/*
1789 수들의 합

서로 다른 N 개의 자연수에서 DP 로도 어려울 것 같아 막막했는데,
직접 적어보니 규칙성이 있다는 것을 발견하였다.
(관련 질문글들) 
https://www.acmicpc.net/board/view/17063
https://www.acmicpc.net/board/view/108118

규칙성을 발견했으면 그걸 수식으로 전개하여 (이차방정식)
바로 근을 구하는 방식도 가능하겠지만,
루프를 크게 돌 필요가 없기 때문에 직접 for 문을 순회해도 가능하다. 

S의 최댓값 4294967295 의 제곱근값인 65535 까지 순회했다가 틀림
=> 정확히는 n*(n+1)/2 + 2 <= S 이므로
제곱근보다는 더 크다
따라서 S 에 최소 (좌변의 분모에 있던) 2를 곱한 다음에 제곱근을 해야하며,
예제로 만들어봤을 때 N 이 최대 어디까지 만들어지는지 출력해서 테스트해봤다.

1 1 (1개)
2 2 (1개)
3 1+2 (2개)
4 1+3 (2개)
5 2+3 (2개)
6 1+2+3 (3개)
7 1+2+4 (3개)
8 1+2+5 혹은 1+3+4 (3개)
9 1+2+6 혹은 1+3+5 (3개)
10 1+2+3+4 (4개)
11 1+2+3+5 (4개)
...
14 1+2+5+6 (4개)
15 1+2+3+4+5 (5개) 
*/

#include <stdio.h>
int main(void)
{
    long long S;
    long long N = 0;
    scanf("%lld", &S);
    for (int i = 2; i <= 92682; ++i) {
        N += i;
        if (N >= S) {
            printf("%lld\n", i-1);
            break;
        }
    }
    return 0;
}
